//! Partition operations for the categorical physics framework.
//!
//! A partition operation is the fundamental unit of physical interaction:
//! - During the partition lag τ_p, carriers are in undetermined state
//! - The undetermined residue generates entropy
//! - Viscosity μ = τ_c × g emerges from partition parameters

use serde::{Deserialize, Serialize};
use std::time::Instant;

use crate::constants::K_B;

/// A single partition operation between carriers.
///
/// During the partition lag tau_p, the carriers are in undetermined state -
/// neither in initial nor final configuration, but in superposition.
/// This undetermined residue generates entropy.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct PartitionOperation {
    /// Partition lag [s] - time in undetermined state
    tau_p: f64,
    /// Coupling strength [Pa or equivalent]
    coupling_g: f64,
    /// Number of partitions created (typically 3 for ternary)
    n_parts: usize,
}

impl PartitionOperation {
    /// Create a new partition operation.
    pub fn new(tau_p: f64, coupling_g: f64, n_parts: usize) -> Self {
        Self {
            tau_p,
            coupling_g,
            n_parts,
        }
    }

    /// Partition lag [s].
    #[inline]
    pub fn tau_p(&self) -> f64 {
        self.tau_p
    }

    /// Coupling strength [Pa].
    #[inline]
    pub fn coupling_g(&self) -> f64 {
        self.coupling_g
    }

    /// Number of partitions created.
    #[inline]
    pub fn n_parts(&self) -> usize {
        self.n_parts
    }

    /// Entropy generated by this partition: S = k_B × ln(n).
    pub fn entropy_generated(&self) -> f64 {
        if self.n_parts > 1 {
            K_B * (self.n_parts as f64).ln()
        } else {
            0.0
        }
    }

    /// Fraction of time in undetermined state (normalized to ns scale).
    pub fn undetermined_fraction(&self) -> f64 {
        (self.tau_p * 1e9).min(1.0)
    }

    /// Contribution to viscosity from this operation: μ_op = τ_p × g.
    pub fn viscosity_contribution(&self) -> f64 {
        self.tau_p * self.coupling_g
    }

    /// Create a ternary (3-way) partition operation.
    pub fn ternary(tau_p: f64, coupling_g: f64) -> Self {
        Self::new(tau_p, coupling_g, 3)
    }

    /// Create a binary (2-way) partition operation.
    pub fn binary(tau_p: f64, coupling_g: f64) -> Self {
        Self::new(tau_p, coupling_g, 2)
    }

    /// Measure a partition operation using real hardware timing.
    pub fn measure(n_parts: usize, coupling_g: f64) -> Self {
        let start = Instant::now();
        // The measurement itself IS the partition operation
        let elapsed = start.elapsed();
        let tau_p = elapsed.as_secs_f64();

        Self::new(tau_p, coupling_g, n_parts)
    }
}

impl Default for PartitionOperation {
    fn default() -> Self {
        Self::ternary(1e-12, 1.0) // 1 ps, 1 Pa default
    }
}

/// A cascade of partition operations.
///
/// Each molecular collision is a partition operation.
/// A photon traversing a fluid encounters N such operations.
/// The photon's trajectory IS encoded as the sequence of partition outcomes.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PartitionCascade {
    operations: Vec<PartitionOperation>,
}

impl PartitionCascade {
    /// Create an empty cascade.
    pub fn new() -> Self {
        Self {
            operations: Vec::new(),
        }
    }

    /// Create a cascade with pre-allocated capacity.
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            operations: Vec::with_capacity(capacity),
        }
    }

    /// Add an operation to the cascade.
    pub fn add_operation(&mut self, operation: PartitionOperation) {
        self.operations.push(operation);
    }

    /// Total entropy generated by the cascade.
    pub fn total_entropy(&self) -> f64 {
        self.operations.iter().map(|op| op.entropy_generated()).sum()
    }

    /// Total partition lag.
    pub fn total_lag(&self) -> f64 {
        self.operations.iter().map(|op| op.tau_p()).sum()
    }

    /// Number of operations in the cascade.
    pub fn n_operations(&self) -> usize {
        self.operations.len()
    }

    /// Access individual operations.
    pub fn operations(&self) -> &[PartitionOperation] {
        &self.operations
    }

    /// Average partition lag.
    pub fn average_lag(&self) -> f64 {
        if self.operations.is_empty() {
            0.0
        } else {
            self.total_lag() / self.operations.len() as f64
        }
    }

    /// Average coupling strength.
    pub fn average_coupling(&self) -> f64 {
        if self.operations.is_empty() {
            0.0
        } else {
            let sum: f64 = self.operations.iter().map(|op| op.coupling_g()).sum();
            sum / self.operations.len() as f64
        }
    }

    /// Number of possible trajectory encodings: n_parts^N_operations.
    ///
    /// For ternary partitions with N operations: 3^N states.
    pub fn trajectory_states(&self) -> f64 {
        self.operations
            .iter()
            .map(|op| op.n_parts() as f64)
            .fold(1.0, |acc, n| acc * n)
    }

    /// Log10 of trajectory states.
    pub fn trajectory_states_log10(&self) -> f64 {
        self.operations
            .iter()
            .map(|op| (op.n_parts() as f64).log10())
            .sum()
    }

    /// Create a cascade for a path through a fluid.
    ///
    /// N_collisions = n_density × σ × L
    ///
    /// Each collision IS a partition operation producing a ternary outcome.
    pub fn from_path_length(
        n_density: f64,
        sigma: f64,
        path_length: f64,
        tau_c: f64,
        coupling_g: f64,
    ) -> Self {
        let n_collisions = (n_density * sigma * path_length) as usize;

        let mut cascade = Self::with_capacity(n_collisions);
        for _ in 0..n_collisions {
            cascade.add_operation(PartitionOperation::ternary(tau_c, coupling_g));
        }

        cascade
    }

    /// Trit string representation of the cascade.
    ///
    /// Each ternary partition contributes one trit (0, 1, or 2).
    /// Returns a sequence representing possible trajectory encodings.
    pub fn as_trit_string(&self) -> Vec<u8> {
        // For demonstration, we represent the partition structure
        // In practice, specific outcomes would be measured
        self.operations
            .iter()
            .map(|op| (op.n_parts() - 1) as u8) // Max trit value for each partition
            .collect()
    }
}

impl std::ops::Add for PartitionCascade {
    type Output = PartitionCascade;

    fn add(mut self, other: PartitionCascade) -> PartitionCascade {
        self.operations.extend(other.operations);
        self
    }
}

impl FromIterator<PartitionOperation> for PartitionCascade {
    fn from_iter<I: IntoIterator<Item = PartitionOperation>>(iter: I) -> Self {
        Self {
            operations: iter.into_iter().collect(),
        }
    }
}

/// Trait for types that exhibit viscosity through partition structure.
pub trait ViscosityRelation {
    /// Partition lag τ_c [s].
    fn tau_c(&self) -> f64;

    /// Coupling strength g [Pa].
    fn coupling_g(&self) -> f64;

    /// Dynamic viscosity μ = τ_c × g [Pa·s].
    fn viscosity(&self) -> f64 {
        self.tau_c() * self.coupling_g()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_partition_entropy() {
        let op = PartitionOperation::ternary(1e-12, 1.0);
        let entropy = op.entropy_generated();
        // S = k_B × ln(3) ≈ 1.52 × 10^-23 J/K
        let expected = K_B * 3.0_f64.ln();
        assert!((entropy - expected).abs() < 1e-30);
    }

    #[test]
    fn test_binary_vs_ternary_entropy() {
        let binary = PartitionOperation::binary(1e-12, 1.0);
        let ternary = PartitionOperation::ternary(1e-12, 1.0);

        // Ternary generates more entropy: ln(3) > ln(2)
        assert!(ternary.entropy_generated() > binary.entropy_generated());
    }

    #[test]
    fn test_cascade_entropy() {
        let mut cascade = PartitionCascade::new();
        for _ in 0..10 {
            cascade.add_operation(PartitionOperation::ternary(1e-12, 1.0));
        }

        let total = cascade.total_entropy();
        let expected = 10.0 * K_B * 3.0_f64.ln();
        assert!((total - expected).abs() < 1e-28);
    }

    #[test]
    fn test_cascade_from_path() {
        let n_density = 2.5e25; // molecules/m³
        let sigma = 3.6e-19; // m²
        let path_length = 0.001; // 1 mm

        let cascade =
            PartitionCascade::from_path_length(n_density, sigma, path_length, 1e-12, 1e5);

        // Should have approximately n × σ × L collisions
        let expected_n = (n_density * sigma * path_length) as usize;
        assert_eq!(cascade.n_operations(), expected_n);
    }

    #[test]
    fn test_trajectory_states() {
        let mut cascade = PartitionCascade::new();
        for _ in 0..5 {
            cascade.add_operation(PartitionOperation::ternary(1e-12, 1.0));
        }

        // 3^5 = 243 states
        assert!((cascade.trajectory_states() - 243.0).abs() < 0.01);
    }

    #[test]
    fn test_viscosity_contribution() {
        let op = PartitionOperation::new(1e-10, 1e5, 3);
        let viscosity = op.viscosity_contribution();
        // μ = τ × g = 1e-10 × 1e5 = 1e-5 Pa·s
        assert!((viscosity - 1e-5).abs() < 1e-15);
    }

    #[test]
    fn test_cascade_combination() {
        let cascade1: PartitionCascade = (0..3)
            .map(|_| PartitionOperation::ternary(1e-12, 1.0))
            .collect();

        let cascade2: PartitionCascade = (0..5)
            .map(|_| PartitionOperation::ternary(1e-12, 1.0))
            .collect();

        let combined = cascade1 + cascade2;
        assert_eq!(combined.n_operations(), 8);
    }
}
