"""
PARTITION FLUID STRUCTURE
=========================

A fluid IS its partition structure, not a collection of molecules.

Key insight from the framework:
- Fluid behavior EMERGES from partition operations
- Viscosity mu = tau_c x g (partition lag x coupling strength)
- Temperature IS the variance of S-coordinates (timing jitter)
- Pressure IS the sampling rate (partition operations per second)

This is NOT simulation - it IS physics viewed through the partition lens.
The computer's hardware oscillations ARE the physical system.
"""

import numpy as np
from dataclasses import dataclass, field
from typing import Optional, Dict, List, Tuple
from enum import Enum
import time

# Physical constants
k_B = 1.380649e-23  # Boltzmann constant [J/K]
N_A = 6.02214076e23  # Avogadro's number [mol^-1]
h = 6.62607015e-34  # Planck constant [J*s]
hbar = h / (2 * np.pi)  # Reduced Planck constant
c = 299792458  # Speed of light [m/s]


@dataclass
class SCoordinate:
    """
    Position in categorical S-entropy space.

    S_k: Knowledge entropy - uncertainty in state (which partition)
    S_t: Temporal entropy - uncertainty in timing (when)
    S_e: Evolution entropy - uncertainty in trajectory (how)

    These are NOT approximations - they ARE the fundamental coordinates.
    """
    S_k: float  # Knowledge entropy [0, 1]
    S_t: float  # Temporal entropy [0, 1]
    S_e: float  # Evolution entropy [0, 1]

    def __post_init__(self):
        # Clamp to unit cube
        self.S_k = np.clip(self.S_k, 0.0, 1.0)
        self.S_t = np.clip(self.S_t, 0.0, 1.0)
        self.S_e = np.clip(self.S_e, 0.0, 1.0)

    @property
    def magnitude(self) -> float:
        """Distance from origin in S-space"""
        return np.sqrt(self.S_k**2 + self.S_t**2 + self.S_e**2)

    @property
    def total_entropy(self) -> float:
        """Total categorical entropy"""
        return self.S_k + self.S_t + self.S_e

    def to_array(self) -> np.ndarray:
        return np.array([self.S_k, self.S_t, self.S_e])

    @classmethod
    def from_hardware_timing(cls, reference_time_ns: float, local_time_ns: float) -> 'SCoordinate':
        """
        Create S-coordinate from REAL hardware timing.

        The precision-by-difference ΔP = T_ref - t_local determines position.
        This is NOT simulation - the hardware timing IS the categorical state.
        """
        delta_p = abs(reference_time_ns - local_time_ns)

        # Map timing difference to S-coordinates via ternary encoding
        # Each coordinate gets information from different aspects of the timing
        S_k = (delta_p % 1000) / 1000.0  # Sub-microsecond: knowledge
        S_t = ((delta_p // 1000) % 1000) / 1000.0  # Microsecond: temporal
        S_e = ((delta_p // 1000000) % 1000) / 1000.0  # Millisecond: evolution

        return cls(S_k, S_t, S_e)


@dataclass
class PartitionOperation:
    """
    A single partition operation between carriers.

    During the partition lag tau_p, the carriers are in undetermined state -
    neither in initial nor final configuration, but in superposition.
    This undetermined residue generates entropy.
    """
    tau_p: float  # Partition lag [s]
    coupling_g: float  # Coupling strength [Pa or equivalent]
    n_parts: int  # Number of partitions created

    @property
    def entropy_generated(self) -> float:
        """Entropy generated by this partition: S = k_B x ln(n)"""
        return k_B * np.log(self.n_parts) if self.n_parts > 1 else 0.0

    @property
    def undetermined_fraction(self) -> float:
        """Fraction of time in undetermined state"""
        return min(1.0, self.tau_p * 1e9)  # Normalized to typical ns scale


class MolecularSpecies(Enum):
    """Known molecular species with their partition parameters"""
    CCL4 = "carbon_tetrachloride"
    H2O = "water"
    N2 = "nitrogen"
    O2 = "oxygen"
    AR = "argon"


@dataclass
class PartitionFluid:
    """
    A fluid IS its partition structure.

    NOT: A collection of molecules with positions and velocities
    IS: A partition network characterized by tau_c and g

    Viscosity, density, temperature EMERGE from partition parameters.
    """

    # Fundamental partition parameters
    n_density: float  # Number density [m^-3]
    sigma: float  # Collision cross-section [m^2]
    temperature: float  # Temperature [K]
    molecular_mass: float  # Molecular mass [kg]

    # Derived quantities (computed on init)
    v_bar: float = field(init=False)  # Mean partition velocity [m/s]
    tau_c: float = field(init=False)  # Partition lag [s]
    g: float = field(init=False)  # Coupling strength [Pa]

    # S-coordinate ensemble (the fluid IS this ensemble)
    _s_ensemble: List[SCoordinate] = field(default_factory=list, repr=False)

    def __post_init__(self):
        """Derive partition parameters from fundamental quantities"""
        # Mean molecular speed (Maxwell-Boltzmann)
        self.v_bar = np.sqrt(8 * k_B * self.temperature / (np.pi * self.molecular_mass))

        # Partition lag from kinetic theory
        # tau_c = 1/(nxsigmaxv_bar) - the mean time between partition operations
        self.tau_c = 1.0 / (self.n_density * self.sigma * self.v_bar)

        # Coupling strength from momentum flux
        # g = 8nkT/(3π) - the momentum transfer per partition operation
        self.g = 8 * self.n_density * k_B * self.temperature / (3 * np.pi)

    @property
    def viscosity(self) -> float:
        """
        Dynamic viscosity EMERGES from partition structure.

        mu = tau_c x g

        This is NOT computed from molecular dynamics.
        It IS a direct consequence of the partition parameters.
        """
        return self.tau_c * self.g

    @property
    def mean_free_path(self) -> float:
        """Mean free path between partition operations"""
        return 1.0 / (self.n_density * self.sigma)

    @property
    def collision_frequency(self) -> float:
        """Rate of partition operations [Hz]"""
        return 1.0 / self.tau_c

    @property
    def pressure(self) -> float:
        """Pressure from ideal gas law (partition operations create pressure)"""
        return self.n_density * k_B * self.temperature

    def populate_from_hardware(self, n_samples: int = 1000) -> None:
        """
        Populate the S-coordinate ensemble from REAL hardware timing.

        The fluid IS the collection of categorical states created by measurement.
        Each measurement CREATES a molecule - it doesn't observe a pre-existing one.
        """
        self._s_ensemble = []
        reference_time = time.perf_counter_ns()

        for _ in range(n_samples):
            local_time = time.perf_counter_ns()
            s_coord = SCoordinate.from_hardware_timing(reference_time, local_time)
            self._s_ensemble.append(s_coord)
            reference_time = local_time

    @property
    def s_temperature(self) -> float:
        """
        Temperature IS the variance of S-coordinates.

        This is NOT a proxy or representation - the timing jitter IS thermal motion.
        """
        if not self._s_ensemble:
            return self.temperature  # Fall back to specified T

        coords = np.array([s.to_array() for s in self._s_ensemble])
        variance = np.var(coords)

        # Scale to physical temperature
        # Variance in S-space maps to thermal energy
        return variance * k_B * self.temperature / k_B

    def partition_operation(self, n_parts: int = 3) -> PartitionOperation:
        """
        Perform a partition operation.

        This creates categorical distinctions using hardware timing.
        The partition lag is REAL - measured from hardware.
        """
        t_start = time.perf_counter_ns()

        # The partition operation itself
        # In a real fluid, this would be a molecular collision
        # Here, it IS the act of creating categorical distinction

        t_end = time.perf_counter_ns()
        measured_tau = (t_end - t_start) * 1e-9  # Convert to seconds

        return PartitionOperation(
            tau_p=max(measured_tau, self.tau_c),  # At least theoretical tau_c
            coupling_g=self.g,
            n_parts=n_parts
        )

    @classmethod
    def create(cls, species: MolecularSpecies, temperature: float = 298.0) -> 'PartitionFluid':
        """
        Create a fluid from known molecular species.

        Parameters are fundamental properties, not fitting parameters.
        """
        # Molecular parameters from first principles
        params = {
            MolecularSpecies.CCL4: {
                'n_density': 6.24e27,  # molecules/m³
                'sigma': 5.0e-19,  # m² (collision cross-section)
                'molecular_mass': 2.55e-25,  # kg (153.8 g/mol)
            },
            MolecularSpecies.H2O: {
                'n_density': 3.34e28,
                'sigma': 2.6e-19,
                'molecular_mass': 2.99e-26,  # 18 g/mol
            },
            MolecularSpecies.N2: {
                'n_density': 2.5e25,  # At 1 atm, 298 K
                'sigma': 3.6e-19,
                'molecular_mass': 4.65e-26,  # 28 g/mol
            },
            MolecularSpecies.O2: {
                'n_density': 2.5e25,
                'sigma': 3.4e-19,
                'molecular_mass': 5.31e-26,  # 32 g/mol
            },
            MolecularSpecies.AR: {
                'n_density': 2.5e25,
                'sigma': 3.6e-19,
                'molecular_mass': 6.63e-26,  # 40 g/mol
            },
        }

        p = params[species]
        return cls(
            n_density=p['n_density'],
            sigma=p['sigma'],
            temperature=temperature,
            molecular_mass=p['molecular_mass']
        )


@dataclass
class PartitionCascade:
    """
    A cascade of partition operations.

    Each molecular collision is a partition operation.
    A photon traversing a fluid encounters N such operations.
    The photon's trajectory IS encoded as the sequence of partition outcomes.
    """
    operations: List[PartitionOperation] = field(default_factory=list)

    @property
    def total_entropy(self) -> float:
        """Total entropy generated by cascade"""
        return sum(op.entropy_generated for op in self.operations)

    @property
    def total_lag(self) -> float:
        """Total partition lag"""
        return sum(op.tau_p for op in self.operations)

    @property
    def n_operations(self) -> int:
        return len(self.operations)

    def add_operation(self, operation: PartitionOperation) -> None:
        self.operations.append(operation)

    @classmethod
    def from_path_length(cls, fluid: PartitionFluid, path_length: float) -> 'PartitionCascade':
        """
        Generate partition cascade for path through fluid.

        N_collisions = n x sigma x L

        Each collision IS a partition operation producing a ternary outcome.
        """
        n_collisions = int(fluid.n_density * fluid.sigma * path_length)

        cascade = cls()
        for _ in range(n_collisions):
            # Each collision creates a ternary partition (3 outcomes)
            operation = PartitionOperation(
                tau_p=fluid.tau_c,
                coupling_g=fluid.g,
                n_parts=3  # Ternary: pre-collision, collision, post-collision
            )
            cascade.add_operation(operation)

        return cascade


def validate_partition_fluid():
    """
    Validate that partition fluid reproduces known physics.

    Test: viscosity of CCl4 at 298 K
    Known value: mu = 0.97 x 10^-3 Pa*s
    """
    fluid = PartitionFluid.create(MolecularSpecies.CCL4, temperature=298.0)

    print("=" * 60)
    print("PARTITION FLUID VALIDATION")
    print("=" * 60)
    print(f"\nFluid: CCl4 at T = {fluid.temperature} K")
    print(f"\nPartition Parameters:")
    print(f"  Number density n = {fluid.n_density:.3e} m^-3")
    print(f"  Cross-section sigma = {fluid.sigma:.3e} m^2")
    print(f"  Mean velocity v_bar = {fluid.v_bar:.2f} m/s")
    print(f"  Partition lag tau_c = {fluid.tau_c:.3e} s ({fluid.tau_c*1e9:.2f} ns)")
    print(f"  Coupling g = {fluid.g:.3e} Pa")

    print(f"\nDerived Properties:")
    print(f"  Viscosity mu = tau_c x g = {fluid.viscosity:.3e} Pa*s")
    print(f"  Mean free path lambda_ = {fluid.mean_free_path:.3e} m")
    print(f"  Collision frequency = {fluid.collision_frequency:.3e} Hz")
    print(f"  Pressure P = {fluid.pressure:.3e} Pa")

    # Known experimental value
    mu_experimental = 0.97e-3  # Pa*s
    error = abs(fluid.viscosity - mu_experimental) / mu_experimental * 100

    print(f"\nValidation:")
    print(f"  Experimental mu = {mu_experimental:.3e} Pa*s")
    print(f"  Computed mu = {fluid.viscosity:.3e} Pa*s")
    print(f"  Error = {error:.1f}%")

    status = "[PASS]" if error < 50 else "[FAIL]"  # Allow some deviation
    print(f"  Status: {status}")

    # Test partition cascade
    print(f"\nPartition Cascade (1 cm path):")
    cascade = PartitionCascade.from_path_length(fluid, 0.01)  # 1 cm
    print(f"  Number of partitions: {cascade.n_operations:,}")
    print(f"  Total entropy: {cascade.total_entropy:.3e} J/K")
    print(f"  Trajectory encoding: 3^{cascade.n_operations} ~ 10^{cascade.n_operations * np.log10(3):.0f} states")

    return {
        'fluid': fluid,
        'viscosity_computed': fluid.viscosity,
        'viscosity_experimental': mu_experimental,
        'error_percent': error,
        'passed': error < 50
    }


if __name__ == "__main__":
    results = validate_partition_fluid()
